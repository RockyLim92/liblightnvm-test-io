.TH "liblightnvm.h" 3 "Tue May 1 2018" "Version 0.0.1" "liblightnvm" \" -*- nroff -*-
.ad l
.nh
.SH NAME
liblightnvm.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <inttypes\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <liblightnvm_spec\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBnvm_ret\fP"
.br
.RI "\fIEncapsulation and representation of lower-level error conditions\&. \fP"
.ti -1c
.RI "struct \fBnvm_cmd\fP"
.br
.RI "\fIEncapsulation of lowest-level user and admin commands\&. \fP"
.ti -1c
.RI "struct \fBnvm_addr\fP"
.br
.RI "\fIEncapsulation of generic physical nvm addressing\&. \fP"
.ti -1c
.RI "struct \fBnvm_geo\fP"
.br
.RI "\fIRepresentation of device and virtual block geometry\&. \fP"
.ti -1c
.RI "struct \fBnvm_bbt\fP"
.br
.RI "\fIRepresentation of bad-block-table\&. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBNVM_NADDR_MAX\fP   64"
.br
.ti -1c
.RI "#define \fBNVM_DEV_NAME_LEN\fP   32"
.br
.ti -1c
.RI "#define \fBNVM_DEV_PATH_LEN\fP   (\fBNVM_DEV_NAME_LEN\fP + 5)"
.br
.ti -1c
.RI "#define \fBNVM_FLAG_SCRBL\fP   0x200"
.br
.RI "\fIScrambler ON/OFF: Context sensitive\&. \fP"
.ti -1c
.RI "#define \fBNVM_BE_ALL\fP   (\fBNVM_BE_IOCTL\fP | \fBNVM_BE_SYSFS\fP | \fBNVM_BE_LBA\fP)"
.br
.RI "\fIAll be idents\&. \fP"
.ti -1c
.RI "#define \fBNVM_FLAG_DEFAULT\fP   (\fBNVM_FLAG_PMODE_SNGL\fP | \fBNVM_FLAG_SCRBL\fP);"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBnvm_be_id\fP { \fBNVM_BE_ANY\fP =  0x0, \fBNVM_BE_IOCTL\fP =  0x1, \fBNVM_BE_SYSFS\fP =  0x2, \fBNVM_BE_LBA\fP =  0x4 }"
.br
.RI "\fIEnumeration of cmd back-ends used by liblightnvm\&. \fP"
.ti -1c
.RI "enum \fBnvm_pmode\fP { \fBNVM_FLAG_PMODE_SNGL\fP =  0x0, \fBNVM_FLAG_PMODE_DUAL\fP =  0x1, \fBNVM_FLAG_PMODE_QUAD\fP =  0x2 }"
.br
.RI "\fIPlane-mode access for IO\&. \fP"
.ti -1c
.RI "enum \fBnvm_quirks\fP { \fBNVM_QUIRK_PMODE_ERASE_RUNROLL\fP =  0x1, \fBNVM_QUIRK_NSID_BY_NAMECONV\fP =  0x2, \fBNVM_QUIRK_OOB_READ_1ST4BYTES_NULL\fP =  0x4, \fBNVM_QUIRK_OOB_2LRG\fP =  0x8 }"
.br
.RI "\fIFlags for device quirks\&. \fP"
.ti -1c
.RI "enum \fBnvm_meta_mode\fP { \fBNVM_META_MODE_NONE\fP =  0x0, \fBNVM_META_MODE_ALPHA\fP =  0x1, \fBNVM_META_MODE_CONST\fP =  0x2 }"
.br
.RI "\fIEnumeration of pseudo meta mode\&. \fP"
.ti -1c
.RI "enum \fBnvm_bounds\fP { \fBNVM_BOUNDS_CHANNEL\fP =  1, \fBNVM_BOUNDS_LUN\fP =  2, \fBNVM_BOUNDS_PLANE\fP =  4, \fBNVM_BOUNDS_BLOCK\fP =  8, \fBNVM_BOUNDS_PAGE\fP =  16, \fBNVM_BOUNDS_SECTOR\fP =  32 }"
.br
.RI "\fIEnumeration of device bounds\&. \fP"
.ti -1c
.RI "enum \fBnvm_bbt_state\fP { \fBNVM_BBT_FREE\fP =  0x0, \fBNVM_BBT_BAD\fP =  0x1, \fBNVM_BBT_GBAD\fP =  0x2, \fBNVM_BBT_DMRK\fP =  0x4, \fBNVM_BBT_HMRK\fP =  0x8 }"
.br
.RI "\fIRepresentation of valid values of bad-block-table states\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "const char * \fBnvm_pmode_str\fP (int pmode)"
.br
.RI "\fIObtain string representation of the given plane-mode\&. \fP"
.ti -1c
.RI "int \fBnvm_cmd_user\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_cmd\fP *cmd, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIExecute an user command on the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_cmd_admin\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_cmd\fP *cmd, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIExecute an admin command on the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_cmd_vuser\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_cmd\fP *cmd, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIExecute a vector user command on the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_cmd_vadmin\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_cmd\fP *cmd, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIExecute a vector admin command on the given device\&. \fP"
.ti -1c
.RI "void \fBnvm_cmd_pr\fP (struct \fBnvm_cmd\fP *cmd)"
.br
.RI "\fIPrints a text-representation of the given command\&. \fP"
.ti -1c
.RI "void \fBnvm_cmd_vuser_pr\fP (struct \fBnvm_cmd\fP *cmd)"
.br
.RI "\fIPrints a textual presentation of the vuser par of the given command\&. \fP"
.ti -1c
.RI "int \fBnvm_ver_major\fP (void)"
.br
.ti -1c
.RI "int \fBnvm_ver_minor\fP (void)"
.br
.ti -1c
.RI "int \fBnvm_ver_patch\fP (void)"
.br
.ti -1c
.RI "void \fBnvm_ver_pr\fP (void)"
.br
.RI "\fIPrints version information about the library\&. \fP"
.ti -1c
.RI "void \fBnvm_bounds_pr\fP (int mask)"
.br
.RI "\fIPrints a humanly readable description of given boundary mask\&. \fP"
.ti -1c
.RI "ssize_t \fBnvm_lba_pread\fP (struct \fBnvm_dev\fP *dev, void *buf, size_t count, off_t offset)"
.br
.RI "\fIRead up to `count` bytes from the given `device` starting at the given `offset` into the given buffer starting at `buf`\&. \fP"
.ti -1c
.RI "ssize_t \fBnvm_lba_pwrite\fP (struct \fBnvm_dev\fP *dev, const void *buf, size_t count, off_t offset)"
.br
.RI "\fIWrite up to `count` bytes from the buffer starting at `buf` to the given device `dev` at given `offset`\&. \fP"
.ti -1c
.RI "void \fBnvm_ret_pr\fP (const struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIPrints a humanly readable representation the given `struct nvm_ret`\&. \fP"
.ti -1c
.RI "struct \fBnvm_bbt\fP * \fBnvm_bbt_get\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fP addr, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIRetrieves a bad block table from device\&. \fP"
.ti -1c
.RI "int \fBnvm_bbt_set\fP (struct \fBnvm_dev\fP *dev, const struct \fBnvm_bbt\fP *bbt, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIUpdates the bad-block-table on given device using the provided bbt\&. \fP"
.ti -1c
.RI "int \fBnvm_bbt_mark\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fP addrs[], int naddrs, uint16_t flags, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIMark addresses good, bad, or host-bad\&. \fP"
.ti -1c
.RI "int \fBnvm_bbt_flush\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fP addr, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIPersist the bad-block-table at `addr` on device and deallocate managed memory for the given bad-block-table describing the LUN at `addr`\&. \fP"
.ti -1c
.RI "int \fBnvm_bbt_flush_all\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIPersist all bad-block-tables associated with the given `dev`\&. \fP"
.ti -1c
.RI "struct \fBnvm_bbt\fP * \fBnvm_bbt_alloc_cp\fP (const struct \fBnvm_bbt\fP *bbt)"
.br
.RI "\fIAllocate a copy of the given bad-block-table\&. \fP"
.ti -1c
.RI "void \fBnvm_bbt_free\fP (struct \fBnvm_bbt\fP *bbt)"
.br
.RI "\fIDestroys a given bad-block-table\&. \fP"
.ti -1c
.RI "void \fBnvm_bbt_pr\fP (const struct \fBnvm_bbt\fP *bbt)"
.br
.RI "\fIPrints a humanly readable representation of the given bad-block-table\&. \fP"
.ti -1c
.RI "void \fBnvm_bbt_state_pr\fP (int state)"
.br
.RI "\fIPrints a humanly readable representation of the given bad-block-table state\&. \fP"
.ti -1c
.RI "void \fBnvm_geo_pr\fP (const struct \fBnvm_geo\fP *geo)"
.br
.RI "\fIPrints human readable representation of the given geometry\&. \fP"
.ti -1c
.RI "struct \fBnvm_dev\fP * \fBnvm_dev_open\fP (const char *dev_path)"
.br
.RI "\fICreates a handle to given device path\&. \fP"
.ti -1c
.RI "struct \fBnvm_dev\fP * \fBnvm_dev_openf\fP (const char *dev_path, int flags)"
.br
.RI "\fICreates a handle to given device path\&. \fP"
.ti -1c
.RI "void \fBnvm_dev_close\fP (struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIDestroys device-handle\&. \fP"
.ti -1c
.RI "void \fBnvm_dev_attr_pr\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIPrints misc\&. \fP"
.ti -1c
.RI "void \fBnvm_dev_pr\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIPrints all information about the device associated with the given handle\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_fd\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the file-descriptor associated with the given device\&. \fP"
.ti -1c
.RI "const char * \fBnvm_dev_get_name\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the name associated with the given device\&. \fP"
.ti -1c
.RI "const char * \fBnvm_dev_get_path\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the path associated with the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_nsid\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the NVME namespace identifier of the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_verid\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the verid of the given device\&. \fP"
.ti -1c
.RI "uint32_t \fBnvm_dev_get_mccap\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the media-controller capabilities mask of the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_pmode\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the default plane_mode of the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_set_pmode\fP (struct \fBnvm_dev\fP *dev, int pmode)"
.br
.RI "\fISet the default plane-mode for the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_quirks\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the mask of quirks for the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_set_quirks\fP (struct \fBnvm_dev\fP *dev, int quirks)"
.br
.RI "\fISet the default plane-mode for the given device\&. \fP"
.ti -1c
.RI "struct nvm_spec_ppaf_nand * \fBnvm_dev_get_ppaf\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the ppa-format of the given device\&. \fP"
.ti -1c
.RI "struct nvm_spec_ppaf_nand_mask * \fBnvm_dev_get_ppaf_mask\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the ppa-format mask of the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_meta_mode\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the 'meta-mode' of the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_set_meta_mode\fP (struct \fBnvm_dev\fP *dev, int meta_mode)"
.br
.RI "\fISet the default 'meta-mode' of the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_erase_naddrs_max\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the maximum number of addresses to use when sending erases to device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_bbts_cached\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns whether caching is enabled for bad-block-tables on the device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_be_id\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the backend identifier associated with the given device\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_read_naddrs_max\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fISet the maximum number of addresses to use for reads, that is, when invoking nvm_addr_read\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_get_write_naddrs_max\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fISet the maximum number of addresses to use for writes, that is, when invoking nvm_addr_write\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_set_erase_naddrs_max\fP (struct \fBnvm_dev\fP *dev, int naddrs)"
.br
.RI "\fISet the maximum number of addresses to use for erases, that is, when invoking nvm_addr_erase\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_set_bbts_cached\fP (struct \fBnvm_dev\fP *dev, int bbts_cached)"
.br
.RI "\fISets whether retrieval and changes to bad-block-tables should be cached\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_set_read_naddrs_max\fP (struct \fBnvm_dev\fP *dev, int naddrs)"
.br
.RI "\fISet the maximum number of addresses to use for erases, that is, when invoking nvm_addr_erase\&. \fP"
.ti -1c
.RI "int \fBnvm_dev_set_write_naddrs_max\fP (struct \fBnvm_dev\fP *dev, int naddrs)"
.br
.RI "\fISet the maximum number of addresses to use for erases, that is, when invoking nvm_addr_erase\&. \fP"
.ti -1c
.RI "struct \fBnvm_geo\fP * \fBnvm_dev_get_geo\fP (const struct \fBnvm_dev\fP *dev)"
.br
.RI "\fIReturns the geometry of the given device\&. \fP"
.ti -1c
.RI "void * \fBnvm_buf_alloc\fP (const struct \fBnvm_geo\fP *geo, size_t nbytes)"
.br
.RI "\fIAllocate a buffer aligned to match the given geometry\&. \fP"
.ti -1c
.RI "void * \fBnvm_buf_alloca\fP (size_t alignment, size_t nbytes)"
.br
.RI "\fIAllocate a buffer of the given size with the given alignment\&. \fP"
.ti -1c
.RI "void \fBnvm_buf_fill\fP (char *buf, size_t nbytes)"
.br
.RI "\fIFills `buf` with chars A-Z\&. \fP"
.ti -1c
.RI "void \fBnvm_buf_free\fP (void *buf)"
.br
.RI "\fIFree the given buffer, calling regular 'free' on the buffer might fail\&. \fP"
.ti -1c
.RI "void \fBnvm_buf_pr\fP (char *buf, size_t nbytes)"
.br
.RI "\fIPrints `buf` to stdout\&. \fP"
.ti -1c
.RI "int \fBnvm_buf_to_file\fP (char *buf, size_t nbytes, const char *path)"
.br
.RI "\fIWrite content of buffer into file\&. \fP"
.ti -1c
.RI "int \fBnvm_buf_from_file\fP (char *buf, size_t nbytes, const char *path)"
.br
.RI "\fIRead content of file into buffer\&. \fP"
.ti -1c
.RI "ssize_t \fBnvm_addr_erase\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fP addrs[], int naddrs, uint16_t flags, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIErase nvm at given addresses\&. \fP"
.ti -1c
.RI "ssize_t \fBnvm_addr_write\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fP addrs[], int naddrs, const void *buf, const void *meta, uint16_t flags, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIWrite content of buf to nvm at address(es) \fP"
.ti -1c
.RI "ssize_t \fBnvm_addr_read\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fP addrs[], int naddrs, void *buf, void *meta, uint16_t flags, struct \fBnvm_ret\fP *ret)"
.br
.RI "\fIRead content of nvm at addresses into buf\&. \fP"
.ti -1c
.RI "int \fBnvm_addr_check\fP (struct \fBnvm_addr\fP addr, const struct \fBnvm_geo\fP *geo)"
.br
.RI "\fIChecks whether the given address exceeds bounds of the given geometry\&. \fP"
.ti -1c
.RI "uint64_t \fBnvm_addr_gen2dev\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fP addr)"
.br
.RI "\fIConverts a given physical address generic-format to device-format\&. \fP"
.ti -1c
.RI "struct \fBnvm_addr\fP \fBnvm_addr_dev2gen\fP (struct \fBnvm_dev\fP *dev, uint64_t addr)"
.br
.RI "\fIConverts a given physical address on device-format to generic-format\&. \fP"
.ti -1c
.RI "uint64_t \fBnvm_addr_dev2lba\fP (struct \fBnvm_dev\fP *dev, uint64_t addr)"
.br
.RI "\fIConverts a given physical address on device-format to lba-format\&. \fP"
.ti -1c
.RI "uint64_t \fBnvm_addr_dev2off\fP (struct \fBnvm_dev\fP *dev, uint64_t addr)"
.br
.RI "\fIConverts a given physical address on device-format to lba-offset-format\&. \fP"
.ti -1c
.RI "uint64_t \fBnvm_addr_gen2off\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fP addr)"
.br
.RI "\fIConverts a given physical address on generic-format to byte offset\&. \fP"
.ti -1c
.RI "struct \fBnvm_addr\fP \fBnvm_addr_off2gen\fP (struct \fBnvm_dev\fP *dev, uint64_t off)"
.br
.RI "\fIConverts a given byte offset to physical address on generic-format\&. \fP"
.ti -1c
.RI "uint64_t \fBnvm_addr_gen2lba\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fP addr)"
.br
.RI "\fIConverts a given physical address on generic-format to LBA offset\&. \fP"
.ti -1c
.RI "struct \fBnvm_addr\fP \fBnvm_addr_lba2gen\fP (struct \fBnvm_dev\fP *dev, uint64_t off)"
.br
.RI "\fIConverts a given LBA offset to physical address on generic-format\&. \fP"
.ti -1c
.RI "void \fBnvm_addr_pr\fP (struct \fBnvm_addr\fP addr)"
.br
.RI "\fIPrints a humanly readable representation of the given address\&. \fP"
.ti -1c
.RI "void \fBnvm_addr_prn\fP (struct \fBnvm_addr\fP *addr, unsigned int naddrs)"
.br
.RI "\fIPrints a humanly readable representation of the given list of addresses\&. \fP"
.ti -1c
.RI "struct \fBnvm_vblk\fP * \fBnvm_vblk_alloc\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fP addrs[], int naddrs)"
.br
.RI "\fIAllocate a virtual block, spanning a given set of physical blocks\&. \fP"
.ti -1c
.RI "struct \fBnvm_vblk\fP * \fBnvm_vblk_alloc_line\fP (struct \fBnvm_dev\fP *dev, int ch_bgn, int ch_end, int lun_bgn, int lun_end, int blk)"
.br
.RI "\fIAllocate a virtual block (spanning planes, channels, and LUNs) \fP"
.ti -1c
.RI "void \fBnvm_vblk_free\fP (struct \fBnvm_vblk\fP *vblk)"
.br
.RI "\fIDestroy a virtual block\&. \fP"
.ti -1c
.RI "ssize_t \fBnvm_vblk_erase\fP (struct \fBnvm_vblk\fP *vblk)"
.br
.RI "\fIErase a virtual block\&. \fP"
.ti -1c
.RI "ssize_t \fBnvm_vblk_write\fP (struct \fBnvm_vblk\fP *vblk, const void *buf, size_t count)"
.br
.RI "\fIWrite to a virtual block\&. \fP"
.ti -1c
.RI "ssize_t \fBnvm_vblk_pwrite\fP (struct \fBnvm_vblk\fP *vblk, const void *buf, size_t count, size_t offset)"
.br
.RI "\fIWrite to a virtual block at a given offset\&. \fP"
.ti -1c
.RI "ssize_t \fBnvm_vblk_pad\fP (struct \fBnvm_vblk\fP *vblk)"
.br
.RI "\fIPad the virtual block with synthetic data\&. \fP"
.ti -1c
.RI "ssize_t \fBnvm_vblk_read\fP (struct \fBnvm_vblk\fP *vblk, void *buf, size_t count)"
.br
.RI "\fIRead from a virtual block\&. \fP"
.ti -1c
.RI "ssize_t \fBnvm_vblk_pread\fP (struct \fBnvm_vblk\fP *vblk, void *buf, size_t count, size_t offset)"
.br
.RI "\fIRead from a virtual block at given offset\&. \fP"
.ti -1c
.RI "struct \fBnvm_dev\fP * \fBnvm_vblk_get_dev\fP (struct \fBnvm_vblk\fP *vblk)"
.br
.RI "\fIRetrieve the device associated with the given virtual block\&. \fP"
.ti -1c
.RI "struct \fBnvm_addr\fP * \fBnvm_vblk_get_addrs\fP (struct \fBnvm_vblk\fP *vblk)"
.br
.RI "\fIRetrieve the set of addresses defining the virtual block\&. \fP"
.ti -1c
.RI "int \fBnvm_vblk_get_naddrs\fP (struct \fBnvm_vblk\fP *vblk)"
.br
.RI "\fIRetrieve the number of addresses in the address set of the virtual block\&. \fP"
.ti -1c
.RI "size_t \fBnvm_vblk_get_nbytes\fP (struct \fBnvm_vblk\fP *vblk)"
.br
.RI "\fIRetrieve the size, in bytes, of a given virtual block\&. \fP"
.ti -1c
.RI "size_t \fBnvm_vblk_get_pos_read\fP (struct \fBnvm_vblk\fP *vblk)"
.br
.RI "\fIRetrieve the read cursor position for the given virtual block\&. \fP"
.ti -1c
.RI "size_t \fBnvm_vblk_get_pos_write\fP (struct \fBnvm_vblk\fP *vblk)"
.br
.RI "\fIRetrieve the write cursor position for the given virtual block\&. \fP"
.ti -1c
.RI "int \fBnvm_vblk_set_pos_read\fP (struct \fBnvm_vblk\fP *vblk, size_t pos)"
.br
.RI "\fISet the read cursor position for the given virtual block\&. \fP"
.ti -1c
.RI "int \fBnvm_vblk_set_pos_write\fP (struct \fBnvm_vblk\fP *vblk, size_t pos)"
.br
.RI "\fISet the write cursor position for the given virtual block\&. \fP"
.ti -1c
.RI "void \fBnvm_vblk_pr\fP (struct \fBnvm_vblk\fP *vblk)"
.br
.RI "\fIPrint the virtual block in a humanly readable form\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SH "Define Documentation"
.PP 
.SS "#define \fBNVM_BE_ALL\fP   (\fBNVM_BE_IOCTL\fP | \fBNVM_BE_SYSFS\fP | \fBNVM_BE_LBA\fP)"
.PP
All be idents\&. 
.SS "#define \fBNVM_DEV_NAME_LEN\fP   32"
.SS "#define \fBNVM_DEV_PATH_LEN\fP   (\fBNVM_DEV_NAME_LEN\fP + 5)"
.SS "#define \fBNVM_FLAG_DEFAULT\fP   (\fBNVM_FLAG_PMODE_SNGL\fP | \fBNVM_FLAG_SCRBL\fP);"
.SS "#define \fBNVM_FLAG_SCRBL\fP   0x200"
.PP
Scrambler ON/OFF: Context sensitive\&. 
.SS "#define \fBNVM_NADDR_MAX\fP   64"
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBnvm_bbt_state\fP"
.PP
Representation of valid values of bad-block-table states\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVM_BBT_FREE \fP\fP
Block is free AKA good\&. 
.TP
\fB\fINVM_BBT_BAD \fP\fP
Block is bad\&. 
.TP
\fB\fINVM_BBT_GBAD \fP\fP
Block has grown bad\&. 
.TP
\fB\fINVM_BBT_DMRK \fP\fP
Block has been marked by device side\&. 
.TP
\fB\fINVM_BBT_HMRK \fP\fP
Block has been marked by host side\&. 
.SS "enum \fBnvm_be_id\fP"
.PP
Enumeration of cmd back-ends used by liblightnvm\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVM_BE_ANY \fP\fP
Flag for ANY backend\&. 
.TP
\fB\fINVM_BE_IOCTL \fP\fP
Flag for the IOCTL backend\&. 
.TP
\fB\fINVM_BE_SYSFS \fP\fP
Flag for the IOCTL + sysfs backend\&. 
.TP
\fB\fINVM_BE_LBA \fP\fP
Flag for the IOCTL + sysfs + LBA backend\&. 
.SS "enum \fBnvm_bounds\fP"
.PP
Enumeration of device bounds\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVM_BOUNDS_CHANNEL \fP\fP
.TP
\fB\fINVM_BOUNDS_LUN \fP\fP
.TP
\fB\fINVM_BOUNDS_PLANE \fP\fP
.TP
\fB\fINVM_BOUNDS_BLOCK \fP\fP
.TP
\fB\fINVM_BOUNDS_PAGE \fP\fP
.TP
\fB\fINVM_BOUNDS_SECTOR \fP\fP

.SS "enum \fBnvm_meta_mode\fP"
.PP
Enumeration of pseudo meta mode\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVM_META_MODE_NONE \fP\fP
.TP
\fB\fINVM_META_MODE_ALPHA \fP\fP
.TP
\fB\fINVM_META_MODE_CONST \fP\fP

.SS "enum \fBnvm_pmode\fP"
.PP
Plane-mode access for IO\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVM_FLAG_PMODE_SNGL \fP\fP
Single-plane\&. 
.TP
\fB\fINVM_FLAG_PMODE_DUAL \fP\fP
Dual-plane (NVM_IO_DUAL_ACCESS) 
.TP
\fB\fINVM_FLAG_PMODE_QUAD \fP\fP
Quad-plane (NVM_IO_QUAD_ACCESS) 
.SS "enum \fBnvm_quirks\fP"
.PP
Flags for device quirks\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINVM_QUIRK_PMODE_ERASE_RUNROLL \fP\fP
.TP
\fB\fINVM_QUIRK_NSID_BY_NAMECONV \fP\fP
.TP
\fB\fINVM_QUIRK_OOB_READ_1ST4BYTES_NULL \fP\fP
.TP
\fB\fINVM_QUIRK_OOB_2LRG \fP\fP

.SH "Function Documentation"
.PP 
.SS "int \fBnvm_addr_check\fP (struct \fBnvm_addr\fPaddr, const struct \fBnvm_geo\fP *geo)"
.PP
Checks whether the given address exceeds bounds of the given geometry\&. \fBParameters:\fP
.RS 4
\fIaddr\fP The addr to check 
.br
\fIgeo\fP The geometric bounds to check the given address against 
.RE
.PP
\fBReturns:\fP
.RS 4
A mask of exceeded boundaries 
.RE
.PP

.SS "struct \fBnvm_addr\fP \fBnvm_addr_dev2gen\fP (struct \fBnvm_dev\fP *dev, uint64_taddr)\fC [read]\fP"
.PP
Converts a given physical address on device-format to generic-format\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddr\fP The physical address on device-format to convert 
.RE
.PP
\fBReturns:\fP
.RS 4
Physical address on generic-format 
.RE
.PP

.SS "uint64_t \fBnvm_addr_dev2lba\fP (struct \fBnvm_dev\fP *dev, uint64_taddr)"
.PP
Converts a given physical address on device-format to lba-format\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddr\fP The physical address on device-format to convert 
.RE
.PP
\fBReturns:\fP
.RS 4
Physical address on lba-format 
.RE
.PP

.SS "uint64_t \fBnvm_addr_dev2off\fP (struct \fBnvm_dev\fP *dev, uint64_taddr)"
.PP
Converts a given physical address on device-format to lba-offset-format\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddr\fP The physical address on device-format to convert 
.RE
.PP
\fBReturns:\fP
.RS 4
Physical address on lba-offset-format 
.RE
.PP

.SS "ssize_t \fBnvm_addr_erase\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fPaddrs[], intnaddrs, uint16_tflags, struct \fBnvm_ret\fP *ret)"
.PP
Erase nvm at given addresses\&. \fBNote:\fP
.RS 4
The addresses given to this function are interpreted as block addresses, in contrast to `nvm_addr_mark`, `nvm_addr_write`, and `nvm_addr_read` for which the address is interpreted as a sector address\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddrs\fP Array of memory address 
.br
\fInaddrs\fP Length of array of memory addresses 
.br
\fIflags\fP Access mode 
.br
\fIret\fP Pointer to structure in which to store lower-level status and result\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success\&. On error: returns -1, sets `errno` accordingly, and fills `ret` with lower-level result and status codes 
.RE
.PP

.SS "uint64_t \fBnvm_addr_gen2dev\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fPaddr)"
.PP
Converts a given physical address generic-format to device-format\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddr\fP The physical address on generic-format to convert 
.RE
.PP
\fBReturns:\fP
.RS 4
Physical address on device-format 
.RE
.PP

.SS "uint64_t \fBnvm_addr_gen2lba\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fPaddr)"
.PP
Converts a given physical address on generic-format to LBA offset\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddr\fP The physical address on generic-format to convert 
.RE
.PP
\fBReturns:\fP
.RS 4
Logical address as LBA offset 
.RE
.PP

.SS "uint64_t \fBnvm_addr_gen2off\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fPaddr)"
.PP
Converts a given physical address on generic-format to byte offset\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddr\fP The physical address on generic-format to convert 
.RE
.PP
\fBReturns:\fP
.RS 4
Logical address as byte offset 
.RE
.PP

.SS "struct \fBnvm_addr\fP \fBnvm_addr_lba2gen\fP (struct \fBnvm_dev\fP *dev, uint64_toff)\fC [read]\fP"
.PP
Converts a given LBA offset to physical address on generic-format\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIoff\fP Logical address as LBA offset to convert 
.RE
.PP
\fBReturns:\fP
.RS 4
Physical address on generic-format 
.RE
.PP

.SS "struct \fBnvm_addr\fP \fBnvm_addr_off2gen\fP (struct \fBnvm_dev\fP *dev, uint64_toff)\fC [read]\fP"
.PP
Converts a given byte offset to physical address on generic-format\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIoff\fP Logical address as byte offset to convert 
.RE
.PP
\fBReturns:\fP
.RS 4
Physical address on generic-format 
.RE
.PP

.SS "void \fBnvm_addr_pr\fP (struct \fBnvm_addr\fPaddr)"
.PP
Prints a humanly readable representation of the given address\&. \fBParameters:\fP
.RS 4
\fIaddr\fP The address to print 
.RE
.PP

.SS "void \fBnvm_addr_prn\fP (struct \fBnvm_addr\fP *addr, unsigned intnaddrs)"
.PP
Prints a humanly readable representation of the given list of addresses\&. 
.SS "ssize_t \fBnvm_addr_read\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fPaddrs[], intnaddrs, void *buf, void *meta, uint16_tflags, struct \fBnvm_ret\fP *ret)"
.PP
Read content of nvm at addresses into buf\&. \fBNote:\fP
.RS 4
The addresses given to this function are interpreted as sector addresses, in contrast to `nvm_addr_mark` and `nvm_addr_erase` for which the address is interpreted as a block address\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddrs\fP List of memory address 
.br
\fInaddrs\fP Length of array of memory addresses 
.br
\fIbuf\fP Buffer to store result of read into, must be aligned to device granularity min read and size equal to `naddrs * geo\&.sector_nbytes` 
.br
\fImeta\fP Buffer to store content of metadata, must be of size equal to device `naddrs * geo\&.meta_nbytes` 
.br
\fIflags\fP Access mode 
.br
\fIret\fP Pointer to structure in which to store lower-level status and result\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success\&. On error: returns -1, sets `errno` accordingly, and fills `ret` with lower-level result and status codes 
.RE
.PP

.SS "ssize_t \fBnvm_addr_write\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fPaddrs[], intnaddrs, const void *buf, const void *meta, uint16_tflags, struct \fBnvm_ret\fP *ret)"
.PP
Write content of buf to nvm at address(es) \fBNote:\fP
.RS 4
The addresses given to this function are interpreted as sector addresses, in contrast to nvm_addr_mark and nvm_addr_erase for which the address is interpreted as a block address\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddrs\fP Array of memory address 
.br
\fInaddrs\fP Length of array of memory addresses 
.br
\fIbuf\fP The buffer which content to write, must be aligned to device geometry of minimal write granularity and size equal to `naddrs * geo\&.nbytes` 
.br
\fImeta\fP Buffer containing metadata, must be of size equal to device `naddrs * geo\&.meta_nbytes` 
.br
\fIflags\fP Access mode 
.br
\fIret\fP Pointer to structure in which to store lower-level status and result\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success\&. On error: returns -1, sets `errno` accordingly, and fills `ret` with lower-level result and status codes 
.RE
.PP

.SS "struct \fBnvm_bbt\fP* \fBnvm_bbt_alloc_cp\fP (const struct \fBnvm_bbt\fP *bbt)\fC [read]\fP"
.PP
Allocate a copy of the given bad-block-table\&. \fBParameters:\fP
.RS 4
\fIbbt\fP Pointer to the bad-block-table to copy 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, a pointer to a write-able copy of the given bbt is returned\&. On error, NULL is returned and errno set to indicate the error 
.RE
.PP

.SS "int \fBnvm_bbt_flush\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fPaddr, struct \fBnvm_ret\fP *ret)"
.PP
Persist the bad-block-table at `addr` on device and deallocate managed memory for the given bad-block-table describing the LUN at `addr`\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddr\fP Address of the LUN to flush bad-block-table for 
.br
\fIret\fP Pointer to structure in which to store lower-level status and result 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned, `errno` set to indicate the error and ret filled with lower-level result codes 
.RE
.PP

.SS "int \fBnvm_bbt_flush_all\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_ret\fP *ret)"
.PP
Persist all bad-block-tables associated with the given `dev`\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIret\fP Pointer to structure in which to store lower-level status and result 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned, `errno` set to indicate the error and ret filled with lower-level result codes 
.RE
.PP

.SS "void \fBnvm_bbt_free\fP (struct \fBnvm_bbt\fP *bbt)"
.PP
Destroys a given bad-block-table\&. \fBParameters:\fP
.RS 4
\fIbbt\fP The bad-block-table to destroy 
.RE
.PP

.SS "struct \fBnvm_bbt\fP* \fBnvm_bbt_get\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fPaddr, struct \fBnvm_ret\fP *ret)\fC [read]\fP"
.PP
Retrieves a bad block table from device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddr\fP Address of the LUN to retrieve bad-block-table for 
.br
\fIret\fP Pointer to structure in which to store lower-level status and result 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, a pointer to the bad-block-table is returned\&. On error, NULL is returned, `errno` set to indicate the error and ret filled with lower-level result codes 
.RE
.PP

.SS "int \fBnvm_bbt_mark\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fPaddrs[], intnaddrs, uint16_tflags, struct \fBnvm_ret\fP *ret)"
.PP
Mark addresses good, bad, or host-bad\&. \fBNote:\fP
.RS 4
The addresses given to this function are interpreted as block addresses, in contrast to `nvm_addr_write`, and `nvm_addr_read` which interpret addresses and sector addresses\&.
.RE
.PP
\fBSee also:\fP
.RS 4
`enum nvm_bbt_state`
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddrs\fP Array of memory address 
.br
\fInaddrs\fP Length of memory address array 
.br
\fIflags\fP 0x0 = GOOD, 0x1 = BAD, 0x2 = GROWN_BAD, as well as access mode 
.br
\fIret\fP Pointer to structure in which to store lower-level status and result\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned, `errno` set to indicate the error and ret filled with lower-level result codes 
.RE
.PP

.SS "void \fBnvm_bbt_pr\fP (const struct \fBnvm_bbt\fP *bbt)"
.PP
Prints a humanly readable representation of the given bad-block-table\&. \fBParameters:\fP
.RS 4
\fIbbt\fP The bad-block-table to print 
.RE
.PP

.SS "int \fBnvm_bbt_set\fP (struct \fBnvm_dev\fP *dev, const struct \fBnvm_bbt\fP *bbt, struct \fBnvm_ret\fP *ret)"
.PP
Updates the bad-block-table on given device using the provided bbt\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIbbt\fP The bbt to write to device 
.br
\fIret\fP Pointer to structure in which to store lower-level status and result 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned, `errno` set to indicate the error and ret filled with lower-level result codes 
.RE
.PP

.SS "void \fBnvm_bbt_state_pr\fP (intstate)"
.PP
Prints a humanly readable representation of the given bad-block-table state\&. 
.SS "void \fBnvm_bounds_pr\fP (intmask)"
.PP
Prints a humanly readable description of given boundary mask\&. 
.SS "void* \fBnvm_buf_alloc\fP (const struct \fBnvm_geo\fP *geo, size_tnbytes)"
.PP
Allocate a buffer aligned to match the given geometry\&. \fBNote:\fP
.RS 4
nbytes must be greater than zero and a multiple of minimal granularity 
.PP
Free the buffer using nvm_buf_free
.RE
.PP
\fBParameters:\fP
.RS 4
\fIgeo\fP The geometry to get alignment information from 
.br
\fInbytes\fP The size of the allocated buffer in bytes
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the allocated memory\&. On error: NULL is returned and `errno` set appropriatly 
.RE
.PP

.SS "void* \fBnvm_buf_alloca\fP (size_talignment, size_tnbytes)"
.PP
Allocate a buffer of the given size with the given alignment\&. \fBNote:\fP
.RS 4
Free the buffer using nvm_buf_free
.RE
.PP
\fBParameters:\fP
.RS 4
\fIalignment\fP The alignment in bytes 
.br
\fInbytes\fP The size of the buffer in bytes
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the allocated memory\&. On error: NULL is returned and `errno` set appropriatly 
.RE
.PP

.SS "void \fBnvm_buf_fill\fP (char *buf, size_tnbytes)"
.PP
Fills `buf` with chars A-Z\&. \fBParameters:\fP
.RS 4
\fIbuf\fP Pointer to the buffer to fill 
.br
\fInbytes\fP Amount of bytes to fill in buf 
.RE
.PP

.SS "void \fBnvm_buf_free\fP (void *buf)"
.PP
Free the given buffer, calling regular 'free' on the buffer might fail\&. \fBParameters:\fP
.RS 4
\fIbuf\fP Pointer to the buffer to fill 
.br
\fInbytes\fP Amount of bytes to fill in buf 
.RE
.PP

.SS "int \fBnvm_buf_from_file\fP (char *buf, size_tnbytes, const char *path)"
.PP
Read content of file into buffer\&. \fBParameters:\fP
.RS 4
\fIbuf\fP Pointer to the buffer 
.br
\fInbytes\fP Size of buf 
.br
\fIpath\fP Source to read from
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on error and errno set to indicate the error\&. 
.RE
.PP

.SS "void \fBnvm_buf_pr\fP (char *buf, size_tnbytes)"
.PP
Prints `buf` to stdout\&. \fBParameters:\fP
.RS 4
\fIbuf\fP Pointer to the buffer to print 
.br
\fInbytes\fP Amount of bytes of buf to print 
.RE
.PP

.SS "int \fBnvm_buf_to_file\fP (char *buf, size_tnbytes, const char *path)"
.PP
Write content of buffer into file\&. \fBParameters:\fP
.RS 4
\fIbuf\fP Pointer to the buffer 
.br
\fInbytes\fP Size of buf 
.br
\fIpath\fP Destination where buffer will be dumped to
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on error and errno set to indicate the error\&. 
.RE
.PP

.SS "int \fBnvm_cmd_admin\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_cmd\fP *cmd, struct \fBnvm_ret\fP *ret)"
.PP
Execute an admin command on the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIcmd\fP The command to execute 
.br
\fIret\fP Pointer to struct to fill with lower-level result-codes
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned, `errno` set to indicate the error and ret filled with lower-level result codes 
.RE
.PP

.SS "void \fBnvm_cmd_pr\fP (struct \fBnvm_cmd\fP *cmd)"
.PP
Prints a text-representation of the given command\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command to print 
.RE
.PP

.SS "int \fBnvm_cmd_user\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_cmd\fP *cmd, struct \fBnvm_ret\fP *ret)"
.PP
Execute an user command on the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIcmd\fP The command to execute 
.br
\fIret\fP Pointer to struct to fill with lower-level result-codes
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned, `errno` set to indicate the error and ret filled with lower-level result codes 
.RE
.PP

.SS "int \fBnvm_cmd_vadmin\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_cmd\fP *cmd, struct \fBnvm_ret\fP *ret)"
.PP
Execute a vector admin command on the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIcmd\fP The command to execute 
.br
\fIret\fP Pointer to struct to fill with lower-level result-codes
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned, `errno` set to indicate the error and ret filled with lower-level result codes 
.RE
.PP

.SS "int \fBnvm_cmd_vuser\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_cmd\fP *cmd, struct \fBnvm_ret\fP *ret)"
.PP
Execute a vector user command on the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIcmd\fP The command to execute 
.br
\fIret\fP Pointer to struct to fill with lower-level result-codes
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned, `errno` set to indicate the error and ret filled with lower-level result codes 
.RE
.PP

.SS "void \fBnvm_cmd_vuser_pr\fP (struct \fBnvm_cmd\fP *cmd)"
.PP
Prints a textual presentation of the vuser par of the given command\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command to print 
.RE
.PP

.SS "void \fBnvm_dev_attr_pr\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Prints misc\&. device attribute associated with the given handle
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP

.SS "void \fBnvm_dev_close\fP (struct \fBnvm_dev\fP *dev)"
.PP
Destroys device-handle\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP

.SS "int \fBnvm_dev_get_bbts_cached\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns whether caching is enabled for bad-block-tables on the device\&. \fBNote:\fP
.RS 4
0 = cache disabled 1 = cache enabled
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP

.SS "int \fBnvm_dev_get_be_id\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the backend identifier associated with the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP

.SS "int \fBnvm_dev_get_erase_naddrs_max\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the maximum number of addresses to use when sending erases to device\&. That is, when invoking nvm_addr_erase\&.
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP

.SS "int \fBnvm_dev_get_fd\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the file-descriptor associated with the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, file descriptor is returned 
.RE
.PP

.SS "struct \fBnvm_geo\fP* \fBnvm_dev_get_geo\fP (const struct \fBnvm_dev\fP *dev)\fC [read]\fP"
.PP
Returns the geometry of the given device\&. \fBNote:\fP
.RS 4
See struct \fBnvm_geo\fP for the specifics of the returned geometry
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open`
.RE
.PP
\fBReturns:\fP
.RS 4
The geometry (struct \fBnvm_geo\fP) of given device handle 
.RE
.PP

.SS "uint32_t \fBnvm_dev_get_mccap\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the media-controller capabilities mask of the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, capabilities mask is returned 
.RE
.PP

.SS "int \fBnvm_dev_get_meta_mode\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the 'meta-mode' of the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, meta-mode is returned 
.RE
.PP

.SS "const char* \fBnvm_dev_get_name\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the name associated with the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, string is returned\&. On error, NULL is returned\&. 
.RE
.PP

.SS "int \fBnvm_dev_get_nsid\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the NVME namespace identifier of the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open`
.RE
.PP
\fBReturns:\fP
.RS 4
On success, NVME namespace identifier is returned\&. 
.RE
.PP

.SS "const char* \fBnvm_dev_get_path\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the path associated with the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, string is returned\&. On error, NULL is returned\&. 
.RE
.PP

.SS "int \fBnvm_dev_get_pmode\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the default plane_mode of the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, pmode flag is returned 
.RE
.PP

.SS "struct nvm_spec_ppaf_nand* \fBnvm_dev_get_ppaf\fP (const struct \fBnvm_dev\fP *dev)\fC [read]\fP"
.PP
Returns the ppa-format of the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, ppa-format is returned 
.RE
.PP

.SS "struct nvm_spec_ppaf_nand_mask* \fBnvm_dev_get_ppaf_mask\fP (const struct \fBnvm_dev\fP *dev)\fC [read]\fP"
.PP
Returns the ppa-format mask of the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, ppa-format mask is returned 
.RE
.PP

.SS "int \fBnvm_dev_get_quirks\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the mask of quirks for the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, quirk mask is returned 
.RE
.PP

.SS "int \fBnvm_dev_get_read_naddrs_max\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Set the maximum number of addresses to use for reads, that is, when invoking nvm_addr_read\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP

.SS "int \fBnvm_dev_get_verid\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Returns the verid of the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, verid is returned 
.RE
.PP

.SS "int \fBnvm_dev_get_write_naddrs_max\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Set the maximum number of addresses to use for writes, that is, when invoking nvm_addr_write\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP

.SS "struct \fBnvm_dev\fP* \fBnvm_dev_open\fP (const char *dev_path)\fC [read]\fP"
.PP
Creates a handle to given device path\&. \fBParameters:\fP
.RS 4
\fIdev_path\fP Path of the device to open e\&.g\&. '/dev/nvme0n1'
.RE
.PP
\fBReturns:\fP
.RS 4
A handle to the device 
.RE
.PP

.SS "struct \fBnvm_dev\fP* \fBnvm_dev_openf\fP (const char *dev_path, intflags)\fC [read]\fP"
.PP
Creates a handle to given device path\&. \fBParameters:\fP
.RS 4
\fIdev_path\fP Path of the device to open e\&.g\&. '/dev/nvme0n1' 
.br
\fIflags\fP Flags for opening device in different modes
.RE
.PP
\fBReturns:\fP
.RS 4
A handle to the device 
.RE
.PP

.SS "void \fBnvm_dev_pr\fP (const struct \fBnvm_dev\fP *dev)"
.PP
Prints all information about the device associated with the given handle\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.RE
.PP

.SS "int \fBnvm_dev_set_bbts_cached\fP (struct \fBnvm_dev\fP *dev, intbbts_cached)"
.PP
Sets whether retrieval and changes to bad-block-tables should be cached\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIbbts_cached\fP 1 = cache enabled, 0 = cache disabled
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on error and errno set to indicate the error\&. 
.RE
.PP

.SS "int \fBnvm_dev_set_erase_naddrs_max\fP (struct \fBnvm_dev\fP *dev, intnaddrs)"
.PP
Set the maximum number of addresses to use for erases, that is, when invoking nvm_addr_erase\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fInaddrs\fP The maximum
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on error and errno set to indicate the error\&. 
.RE
.PP

.SS "int \fBnvm_dev_set_meta_mode\fP (struct \fBnvm_dev\fP *dev, intmeta_mode)"
.PP
Set the default 'meta-mode' of the given device\&. The meta-mode is a setting used by the \fBnvm_vblk\fP interface to write pseudo-meta data to the out-of-bound area\&.
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fImeta_mode\fP One of: NVM_META_MODE_[NONE|ALPHA|CONST]
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned and errno set to indicate the error\&. 
.RE
.PP

.SS "int \fBnvm_dev_set_pmode\fP (struct \fBnvm_dev\fP *dev, intpmode)"
.PP
Set the default plane-mode for the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIpmode\fP Default plane-mode
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on error and errno set to indicate the error\&. 
.RE
.PP

.SS "int \fBnvm_dev_set_quirks\fP (struct \fBnvm_dev\fP *dev, intquirks)"
.PP
Set the default plane-mode for the given device\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIquirks\fP Mask of `enum nvm_quirks`
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on error and errno set to indicate the error\&. 
.RE
.PP

.SS "int \fBnvm_dev_set_read_naddrs_max\fP (struct \fBnvm_dev\fP *dev, intnaddrs)"
.PP
Set the maximum number of addresses to use for erases, that is, when invoking nvm_addr_erase\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fInaddrs\fP The maximum
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on error and errno set to indicate the error\&. 
.RE
.PP

.SS "int \fBnvm_dev_set_write_naddrs_max\fP (struct \fBnvm_dev\fP *dev, intnaddrs)"
.PP
Set the maximum number of addresses to use for erases, that is, when invoking nvm_addr_erase\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fInaddrs\fP The maximum
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on error and errno set to indicate the error\&. 
.RE
.PP

.SS "void \fBnvm_geo_pr\fP (const struct \fBnvm_geo\fP *geo)"
.PP
Prints human readable representation of the given geometry\&. 
.SS "ssize_t \fBnvm_lba_pread\fP (struct \fBnvm_dev\fP *dev, void *buf, size_tcount, off_toffset)"
.PP
Read up to `count` bytes from the given `device` starting at the given `offset` into the given buffer starting at `buf`\&. \fBNote:\fP
.RS 4
This is equivalent to `pread`/`pwrite` except it takes the opaque `struct \fBnvm_dev\fP *` instead of a file descriptor 
.RE
.PP

.SS "ssize_t \fBnvm_lba_pwrite\fP (struct \fBnvm_dev\fP *dev, const void *buf, size_tcount, off_toffset)"
.PP
Write up to `count` bytes from the buffer starting at `buf` to the given device `dev` at given `offset`\&. \fBNote:\fP
.RS 4
This is equivalent to `pread`/`pwrite` except it takes the opaque `struct \fBnvm_dev\fP *` instead of a file descriptor 
.RE
.PP

.SS "const char* \fBnvm_pmode_str\fP (intpmode)"
.PP
Obtain string representation of the given plane-mode\&. \fBParameters:\fP
.RS 4
\fIpmode\fP The plane-mode to obtain string representation of
.RE
.PP
\fBReturns:\fP
.RS 4
On success, string representation of the given plane-mode\&. On error, 'UNKN'\&. 
.RE
.PP

.SS "void \fBnvm_ret_pr\fP (const struct \fBnvm_ret\fP *ret)"
.PP
Prints a humanly readable representation the given `struct nvm_ret`\&. \fBParameters:\fP
.RS 4
\fIret\fP Pointer to the `struct nvm_ret` to print 
.RE
.PP

.SS "struct \fBnvm_vblk\fP* \fBnvm_vblk_alloc\fP (struct \fBnvm_dev\fP *dev, struct \fBnvm_addr\fPaddrs[], intnaddrs)\fC [read]\fP"
.PP
Allocate a virtual block, spanning a given set of physical blocks\&. \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIaddrs\fP Set of block-addresses forming the virtual block 
.br
\fInaddrs\fP The number of addresses in the address-set
.RE
.PP
\fBReturns:\fP
.RS 4
On success, an opaque pointer to the initialized virtual block is returned\&. On error, NULL and `errno` set to indicate the error\&. 
.RE
.PP

.SS "struct \fBnvm_vblk\fP* \fBnvm_vblk_alloc_line\fP (struct \fBnvm_dev\fP *dev, intch_bgn, intch_end, intlun_bgn, intlun_end, intblk)\fC [read]\fP"
.PP
Allocate a virtual block (spanning planes, channels, and LUNs) \fBParameters:\fP
.RS 4
\fIdev\fP Device handle obtained with `nvm_dev_open` 
.br
\fIch_bgn\fP Beginning of the channel span, as inclusive index 
.br
\fIch_end\fP End of the channel span, as inclusive index 
.br
\fIlun_bgn\fP Beginning of the LUN span, as inclusive index 
.br
\fIlun_end\fP End of the LUN span, as inclusive index 
.br
\fIblk\fP Block index
.RE
.PP
\fBReturns:\fP
.RS 4
On success, an opaque pointer to the initialized virtual block is returned\&. On error, NULL and `errno` set to indicate the error\&. 
.RE
.PP

.SS "ssize_t \fBnvm_vblk_erase\fP (struct \fBnvm_vblk\fP *vblk)"
.PP
Erase a virtual block\&. \fBNote:\fP
.RS 4
Erasing a vblk will reset internal position pointers
.RE
.PP
\fBParameters:\fP
.RS 4
\fIvblk\fP The virtual block to erase 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, the number of bytes erased is returned\&. On error, -1 is returned and `errno` set to indicate the error\&. 
.RE
.PP

.SS "void \fBnvm_vblk_free\fP (struct \fBnvm_vblk\fP *vblk)"
.PP
Destroy a virtual block\&. \fBParameters:\fP
.RS 4
\fIvblk\fP The virtual block to destroy 
.RE
.PP

.SS "struct \fBnvm_addr\fP* \fBnvm_vblk_get_addrs\fP (struct \fBnvm_vblk\fP *vblk)\fC [read]\fP"
.PP
Retrieve the set of addresses defining the virtual block\&. \fBParameters:\fP
.RS 4
\fIvblk\fP The entity to retrieve information from 
.RE
.PP

.SS "struct \fBnvm_dev\fP* \fBnvm_vblk_get_dev\fP (struct \fBnvm_vblk\fP *vblk)\fC [read]\fP"
.PP
Retrieve the device associated with the given virtual block\&. \fBParameters:\fP
.RS 4
\fIvblk\fP The entity to retrieve information from 
.RE
.PP

.SS "int \fBnvm_vblk_get_naddrs\fP (struct \fBnvm_vblk\fP *vblk)"
.PP
Retrieve the number of addresses in the address set of the virtual block\&. \fBParameters:\fP
.RS 4
\fIvblk\fP The entity to retrieve information from 
.RE
.PP

.SS "size_t \fBnvm_vblk_get_nbytes\fP (struct \fBnvm_vblk\fP *vblk)"
.PP
Retrieve the size, in bytes, of a given virtual block\&. \fBParameters:\fP
.RS 4
\fIvblk\fP The entity to retrieve information from 
.RE
.PP

.SS "size_t \fBnvm_vblk_get_pos_read\fP (struct \fBnvm_vblk\fP *vblk)"
.PP
Retrieve the read cursor position for the given virtual block\&. \fBParameters:\fP
.RS 4
\fIvblk\fP The entity to retrieve information from 
.RE
.PP

.SS "size_t \fBnvm_vblk_get_pos_write\fP (struct \fBnvm_vblk\fP *vblk)"
.PP
Retrieve the write cursor position for the given virtual block\&. \fBParameters:\fP
.RS 4
\fIvblk\fP The entity to retrieve information from 
.RE
.PP

.SS "ssize_t \fBnvm_vblk_pad\fP (struct \fBnvm_vblk\fP *vblk)"
.PP
Pad the virtual block with synthetic data\&. \fBNote:\fP
.RS 4
Assumes that you have used nvm_vblk_write and now want to fill the remaining virtual block in order to meet block write-before-read constraints
.RE
.PP
\fBParameters:\fP
.RS 4
\fIvblk\fP The virtual block to pad 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, the number of bytes padded is returned and internal position is updated\&. On error, -1 is returned and `errno` set to indicate the error\&. 
.RE
.PP

.SS "void \fBnvm_vblk_pr\fP (struct \fBnvm_vblk\fP *vblk)"
.PP
Print the virtual block in a humanly readable form\&. \fBParameters:\fP
.RS 4
\fIvblk\fP The entity to print information about 
.RE
.PP

.SS "ssize_t \fBnvm_vblk_pread\fP (struct \fBnvm_vblk\fP *vblk, void *buf, size_tcount, size_toffset)"
.PP
Read from a virtual block at given offset\&. 
.SS "ssize_t \fBnvm_vblk_pwrite\fP (struct \fBnvm_vblk\fP *vblk, const void *buf, size_tcount, size_toffset)"
.PP
Write to a virtual block at a given offset\&. \fBNote:\fP
.RS 4
buf must be aligned to device geometry, see struct \fBnvm_geo\fP and nvm_buf_alloc count must be a multiple of min-size, see struct \fBnvm_geo\fP offset must be a multiple of min-size, see struct \fBnvm_geo\fP do not mix use of nvm_vblk_pwrite with nvm_vblk_write on the same virtual block
.RE
.PP
\fBParameters:\fP
.RS 4
\fIvblk\fP The virtual block to write to 
.br
\fIbuf\fP Write content starting at buf 
.br
\fIcount\fP The number of bytes to write 
.br
\fIoffset\fP Start writing offset bytes within virtual block 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, the number of bytes written is returned\&. On error, -1 is returned and `errno` set to indicate the error\&. 
.RE
.PP

.SS "ssize_t \fBnvm_vblk_read\fP (struct \fBnvm_vblk\fP *vblk, void *buf, size_tcount)"
.PP
Read from a virtual block\&. 
.SS "int \fBnvm_vblk_set_pos_read\fP (struct \fBnvm_vblk\fP *vblk, size_tpos)"
.PP
Set the read cursor position for the given virtual block\&. \fBParameters:\fP
.RS 4
\fIvblk\fP The vblk to change 
.br
\fIpos\fP The new read cursor
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned and `errno` set to indicate the error 
.RE
.PP

.SS "int \fBnvm_vblk_set_pos_write\fP (struct \fBnvm_vblk\fP *vblk, size_tpos)"
.PP
Set the write cursor position for the given virtual block\&. \fBParameters:\fP
.RS 4
\fIvblk\fP The vblk to change 
.br
\fIpos\fP The new write cursor
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned\&. On error, -1 is returned and `errno` set to indicate the error 
.RE
.PP

.SS "ssize_t \fBnvm_vblk_write\fP (struct \fBnvm_vblk\fP *vblk, const void *buf, size_tcount)"
.PP
Write to a virtual block\&. \fBNote:\fP
.RS 4
buf must be aligned to device geometry, see struct \fBnvm_geo\fP and nvm_buf_alloc count must be a multiple of min-size, see struct \fBnvm_geo\fP do not mix use of nvm_vblk_pwrite with nvm_vblk_write on the same virtual block
.RE
.PP
\fBParameters:\fP
.RS 4
\fIvblk\fP The virtual block to write to 
.br
\fIbuf\fP Write content starting at buf 
.br
\fIcount\fP The number of bytes to write 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, the number of bytes written is returned and vblk internal position is updated\&. On error, -1 is returned and `errno` set to indicate the error\&. 
.RE
.PP

.SS "int \fBnvm_ver_major\fP (void)"\fBReturns:\fP
.RS 4
the 'major' version of the library 
.RE
.PP

.SS "int \fBnvm_ver_minor\fP (void)"\fBReturns:\fP
.RS 4
the 'minor' version of the library 
.RE
.PP

.SS "int \fBnvm_ver_patch\fP (void)"\fBReturns:\fP
.RS 4
the 'patch' version of the library 
.RE
.PP

.SS "void \fBnvm_ver_pr\fP (void)"
.PP
Prints version information about the library\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for liblightnvm from the source code\&.
